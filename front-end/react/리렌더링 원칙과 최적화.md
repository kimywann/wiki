# 리렌더링 원칙과 리액트 최적화 기초

## **1. ✅ 리렌더링이 일어나는 조건**

### **✔️ 상태(state)가 바뀔 때**

- 컴포넌트 내부에서 useState나 useReducer로 관리하는 상태가 바뀌면 **그 컴포넌트가 리렌더링**됨.

### **✔️ 부모 컴포넌트가 리렌더링되면**

- 자식 컴포넌트도 **함께 리렌더링**됨.
  ➤ 특히, 부모가 자식에게 **props를 전달하고 있다면 더더욱**

> 💡 예:

> Signup 컴포넌트에서 onChange로 상태를 변경

> → Signup 리렌더링

> → 그 안의 Input, EmailInput도 다시 렌더링됨

---

## **2. ⚠️ 리렌더링이 무조건 나쁜 건 아니지만…**

- **불필요한 리렌더링**은 성능에 악영향 줄 수 있어요.
- 특히 **입력이 많은 UI**, **대규모 리스트**, **애니메이션 등 퍼포먼스 민감한 요소**에서는 피해야 합니다.

---

## **3. ✨** **memo를 사용한 최적화**

### **📌** 

### **React.memo(Component)**

- 컴포넌트를 감싸서 **props가 변경되지 않으면 리렌더링을 막는** 함수예요.
- 자식 컴포넌트를 감쌀 때 유용해요.

```jsx
const MemoizedInput = React.memo(Input);
```

- ⚠️ 단, 내부에 **함수나 객체를 props로 넘기면** 매번 새로 만들어져서 memo 효과가 없어짐.

---

## **4. 🧠 함수 참조 유지하기:** **useCallback**

### **✅ 문제 상황**

```jsx
const onChange = (e) => setValue(e.target.value);
```

- onChange는 함수지만, 컴포넌트가 리렌더링되면 **매번 새로 생성되는 함수**예요.
- 따라서 자식 컴포넌트에 넘길 때, memo가 있어도 **“다른 props로 인식”**됨.

### **✅ 해결 방법**

```jsx
const onChange = useCallback((e) => {
  setValue(e.target.value);
}, []);
```

- useCallback은 함수의 참조를 **유지**시켜줍니다.

> 📌 배열([])은 **언제 참조를 바꿔야 할지 알려주는 힌트(의존성)**

> 즉, 안에 있는 값이 바뀌면 새 함수로 갱신됨.

---

## **5. 📦 객체의 참조 유지:** **useMemo**

### **✨ 예:**

```jsx
const config = useMemo(() => ({ theme: "dark" }), []);
```

- 객체도 {} !== {}처럼 참조가 다르면 memo가 무력화됨
- useMemo로 객체를 기억시켜두면, memo 컴포넌트에 넘기더라도 **props가 바뀌지 않은 것처럼 인식**됨

---

## **6. 🧪 리액트 19의 변화:** 

## **React Compiler**

- React 19부터는 memo, useMemo, useCallback 없이도 **자동으로 최적화**해주는 기능이 추가됨
- 다만, **완전히 대체되진 않았고** 특정 상황에서는 여전히 직접 써야 할 수도 있음

## **🎯 마무리 복습 포인트**

| **키워드**  | **설명**                                    | **언제 쓰나요?**              |
| ----------- | ------------------------------------------- | ----------------------------- |
| memo        | props 안 바뀌면 자식 컴포넌트 리렌더링 막음 | 자식 컴포넌트 성능 최적화     |
| useCallback | 함수 참조 유지                              | props로 함수 넘길 때          |
| useMemo     | 객체 참조 유지                              | props로 객체 넘길 때          |
| ref         | 리렌더링 되어도 참조 유지                   | DOM 제어하거나 focus 줄 때 등 |
| 의존성 배열 | 언제 새로운 함수/객체로 바뀌어야 할지 조건  | 항상 정확하게 작성해야 함     |

## **💡 공부 팁**

- **console.log()**를 활용해서 렌더링 시점과 함수 참조가 바뀌는지 확인해보세요.
- React.memo는 언제나 좋은 건 아님 → **성능에 진짜 문제 있을 때만 쓰기!**
- 객체/함수 비교는 값이 아니라 “참조”임을 꼭 기억하세요!
